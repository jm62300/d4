("help,h", "Help screen")
("input,i", boost::program_options::value<std::string>(), "(required) Path to get the input file")
("input-type", boost::program_options::value<std::string>()->default_value("cnf"), "The input type")
("dump-file", boost::program_options::value<std::string>()->default_value("/dev/null"), "The file where is printed out the dDNNF if required.")
("solver,s", boost::program_options::value<std::string>()->default_value("glucose"), "The solver we will use")
("preproc-solver,ps", boost::program_options::value<std::string>()->default_value("glucose"), "The solver we will use in the preproc")
("preproc,p",boost::program_options::value<std::string>()->default_value("basic"), "The preprocessing technique we will use (basic, backbone, vivification, occElimination, combinaison, sharp-equiv, equiv).")
("preproc-reducer-iteration",boost::program_options::value<int>()->default_value(10), "The number of iterations for the preproc that call reducer (-1 means we want to apply until we reach a fix point).")
("preproc-timeout",boost::program_options::value<int>()->default_value(0), "The time in second given to the preproc (0 means no timeout).")
("preproc-onlyGates",boost::program_options::value<bool>()->default_value(false), "Set to true if we only use gates detection for computing the bi-partition.")
("preproc-ordered",boost::program_options::value<bool>()->default_value(false), "Set to true if the elimination need to follow some order.")
("preproc-strong-elim",boost::program_options::value<bool>()->default_value(false), "If set to true, then the variable are elminated whatever the impact on the size of the formula.")
("occurrence-manager",boost::program_options::value<std::string>()->default_value("dynamic"),"The occurrence manager used (dynamic, dynamicBlockedSimp or dynamicPureSimp). ")
("branching-heuristic", boost::program_options::value<std::string>()->default_value("hybrid-partial-classic"),"The branching heuristic used (classic or large-clause if d4 selects first literals in large clauses.)")
("branching-heuristic-limit-clause",boost::program_options::value<unsigned>()->default_value(30),"The size limit for the branching heuristic based on large clauses.")
("scoring-method,sm",boost::program_options::value<std::string>()->default_value("vsads"),"The scoring method used for selecting the next variable. [mom, dlcs, vsids, vsads, jwts]")
("scoring-method-freq-decay",boost::program_options::value<unsigned>()->default_value(128),"Gives the decay frequency")
("phase-heuristic,ph",boost::program_options::value<std::string>()->default_value("polarity"),"The way the phase of the next decision is selected (false, true, polarity or occurrence).")
("phase-heuristic-reversed,pha", boost::program_options::value<bool>()->default_value(false), "Consider or not the reverse of the current phase.")
("partialOrder-heuristic",boost::program_options::value<std::string>()->default_value("tree-decomposition"),"The method used to compute a cut. [none, tree-decomposition]")
("partialOrder-heuristic-partitioner",boost::program_options::value<std::string>()->default_value("patoh"),"The partitioner we will call (patoh).")
("partialOrder-heuristic-tree-decomposition",boost::program_options::value<std::string>()->default_value("tree-width"),"The tree decomposition technique used (tree-partition, tree-width).")
("partialOrder-heuristic-hyper-graph-representation",boost::program_options::value<std::string>()->default_value("dual"),"The hyper graph representation used (dual).")
("partialOrder-heuristic-graph-representation",boost::program_options::value<std::string>()->default_value("primal"),"The graph representation used (primal).")
("partialOrder-heuristic-representation-simplication",boost::program_options::value<bool>()->default_value(true),"Set to true if the graph extractor use some simplification.")
("partialOrder-heuristic-tree-decomposition-method",boost::program_options::value<std::string>()->default_value("flow-cutter"),"The tool used for computing the tree decomposition (flow-cutter).")
("cache-reduction-strategy,crs", boost::program_options::value<std::string>()->default_value("none"), "The strategy used to reduce the cache structure [none, expectation, cache or sharpSAT].")
("cache-reduction-strategy-cachet-limit,crscl", boost::program_options::value<unsigned long>()->default_value(10UL * (1<<21)), "The limit in term of number of entries, the cachet reduction strategy allows.")
("cache-reduction-strategy-expectation-limit,crsel", boost::program_options::value<unsigned long>()->default_value(100000), "The frequency in term of number of negative hits used for the expectation reduction strategy allows.")
("cache-reduction-strategy-expectation-ratio,crser", boost::program_options::value<double>()->default_value(0.3), "The ratio used to decide if a clause can be kept or not.")
("cache-size-first-page", boost::program_options::value<unsigned long>()->default_value((1UL<<32)), "The block size of memory allocated for the first page of the cache structure.")
("cache-size-additional-page", boost::program_options::value<unsigned long>()->default_value((1UL<<29)), "The block size of memory allocated for the next page of the cache structure.")
("cache-store-strategy", boost::program_options::value<std::string>()->default_value("not-touched"), "The strategy used to store the clause in a bucket (all, not-binary and not-touched).")
("cache-clause-representation", boost::program_options::value<std::string>()->default_value("clause"), "The way the clause are represented in the cache (combi, sym, clause and index).")
("cache-clause-representation-combi-limitVar-sym", boost::program_options::value<unsigned>()->default_value(20), "In the mixed strategy, if we have less than a given number of variable then we use the symmetry caching representation.")
("cache-clause-representation-combi-limitVar-index", boost::program_options::value<unsigned>()->default_value(2000), "In the mixed strategy, if we have more than a given number of variable then we use the index caching representation.")
("cache-limit-number-variable", boost::program_options::value<unsigned>()->default_value(100000), "The number of variables threshold used to decide if the cache is used or not.")
("cache-limit-ratio", boost::program_options::value<double>()->default_value(0), "For the dynamic limit, posHit/negHit < ratio.")
("cache-activated", boost::program_options::value<bool>()->default_value(true), "Activate or not the cache.")
("cache-method", boost::program_options::value<std::string>()->default_value("list"), "The way the collision are handled (no-collision or list).")
("float-precision,fp", boost::program_options::value<int>()->default_value(128), "The precision for the float.")
("float,f", boost::program_options::value<bool>()->default_value(false), "If the count is computed as a float or not.")
("keyword-output-format-solution", boost::program_options::value<std::string>()->default_value("s"), "The keyword prints in front of the solution when it is printed out.")
("output-format", boost::program_options::value<std::string>()->default_value("classic"), "The way the solution is printed out ('classic' only gives the number of solution after printing 's', 'competition' follows the MC competition 2021).")
("translate,t", boost::program_options::value<std::string>()->default_value("none"), "Translate the input formula in another formula before solving (none, cnf or pcnf (cnf with projected variable))")
("remove-gates", boost::program_options::value<bool>()->default_value(false), "If this option is activated and if the problem is a circuit, then some gates can be removed during the search if those ones are not active.")
("query", boost::program_options::value<std::string>()->default_value("/dev/null"), "This file contains the queries we would like to be answered by the d-DNNF formula.")
